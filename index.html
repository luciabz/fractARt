<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FractArt Controller</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Archivo+Black&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-50 text-gray-900 ">
  <div class="container mx-auto p-6 space-y-8">
    <!-- Título -->
    <header class="text-center">
      <h1 class="text-4xl font-bold">Welcome FractArt</h1>
    </header>

    <!-- Información del proyector -->
    <section class="bg-white shadow-md rounded-lg p-6 space-y-6">
      <!-- Imagen del proyector y estado -->
      <div class="flex items-center justify-between">
        <div class="space-y-2">
          <h2 class="text-2xl font-semibold">FractArt Projector</h2>
          <p id="projector-status" class="text-gray-600">Estado: <span class="font-bold text-green-600">Apagado</span></p>
        </div>
        
        <img src="./proyector.png" alt="Proyector" class="w-24 h-24 rounded-lg shadow-lg">
      </div>

      <!-- Indicador de batería -->
      <div>
        <label class="block text-gray-600 text-sm mb-2">Batería</label>
        <div class="flex items-center space-x-4">
          <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
            <div class="bg-green-500 h-full rounded-full" style="width: 80%;"></div>
          </div>
          <span class="text-gray-600 font-semibold">80%</span>
        </div>
      </div>

      <!-- Botón de encendido con hover -->
      <div class="flex items-center justify-center">
        <button id="power-button" class="bg-gray-200 hover:bg-green-500 text-gray-900 px-6 py-3 rounded-full flex items-center transition">
          <img src="./systemshutdown_104277.svg" alt="Encender/Apagar" class="w-8 h-8 mr-2">
          <span id="power-text">Encender</span>
        </button>
      </div>

      <!-- Botón de transmitir -->
      <div class="flex items-center justify-center mt-6">
        <button id="connect-button" class="bg-blue-200 hover:bg-blue-500 text-white px-6 py-3 rounded-full flex items-center transition">
          <span id="connect-text">Buscar y Conectar</span>
        </button>
      </div>
    </section>

    <!-- Ajustes del fractal -->
    <section class="bg-white shadow-md rounded-lg p-6">
      <h2 class="text-2xl font-semibold mb-4">Ajustar Fractal</h2>
      <div class="grid grid-cols-2 gap-4">
        <!-- Zoom Slider -->
        <div>
          <label class="block text-sm mb-2 text-gray-600">Zoom</label>
          <input type="range" id="zoom-slider" min="1" max="10" step="0.1" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none focus:outline-none">
          <p id="zoom-value" class="mt-2 text-sm text-gray-400">Zoom: 1</p>
        </div>
        <!-- Color Picker -->
        <div>
          <label class="block text-sm mb-2 text-gray-600">Color</label>
          <input type="color" id="color-picker" class="w-full h-10 bg-gray-100 border border-gray-300 rounded-md">
        </div>

      </div>
        <div class="grid grid-cols-1 gap-4 mt-6"> <!-- Cambié grid-cols-3 a grid-cols-1 -->
          <!-- Parte Real -->
          <div>
            <label class="block text-sm mb-2 text-gray-600">Parte Real (c)</label>
            <input type="number" id="real-part" step="0.01" class="w-full p-2 bg-gray-100 border border-gray-300 rounded-md" value="-0.7">
          </div>
          <!-- Parte Imaginaria -->
          <div>
            <label class="block text-sm mb-2 text-gray-600">Parte Imaginaria (c)</label>
            <input type="number" id="imaginary-part" step="0.01" class="w-full p-2 bg-gray-100 border border-gray-300 rounded-md" value="0.27015">
          </div>
          <!-- Iteraciones -->
          <div>
            <label class="block text-sm mb-2 text-gray-600">Número de Iteraciones</label>
            <input type="number" id="iterations" class="w-full p-2 bg-gray-100 border border-gray-300 rounded-md" value="1000">
          </div>
      </div>
    </section>


    <!-- Opciones de fractales -->
    <section class="bg-white shadow-md rounded-lg p-6">
      <h2 class="text-2xl font-semibold mb-4">Seleccionar Fractal</h2>
      <select id="fractal-selector" class="w-full p-2 bg-gray-100 border border-gray-300 rounded-md">
        <option value="mandelbrot">Mandelbrot</option>
        <option value="julia">Julia</option>
        <option value="sierpinski">Sierpinski</option>
      </select>
    </section>

    <!-- Generador de fractales -->
    <section class="bg-white shadow-md rounded-lg p-6">
      <h2 class="text-2xl font-semibold mb-4">Generador de Fractales</h2>
      <div class="relative">
        <canvas id="fractal-canvas" class="w-full h-64 bg-gray-700 rounded-md"></canvas>
        <p class="absolute bottom-2 right-2 text-gray-400 text-sm">Zoom: <span id="zoom-label">1</span></p>
      </div>
      <div class="flex items-center justify-center mt-4">
        <button id="generate-button" class="bg-purple-500 hover:bg-purple-700 text-white px-6 py-3 rounded-full flex items-center transition">
          Generar Fractal
        </button>
      </div>
    </section>


    <!-- Tiempo de duración -->
    <section class="bg-white shadow-md rounded-lg p-6">
      <h2 class="text-2xl font-semibold mb-4">Tiempo de duración</h2>
      <input type="number" id="duration" placeholder="Duración en horas" class="w-full p-2 bg-gray-100 border border-gray-300 rounded-md">
      <div id="time-counter" class="text-sm text-gray-600 mt-2"></div>
    </section>

    <!-- Modo de presentación -->
    <section class="bg-white shadow-md rounded-lg p-6">
      <h2 class="text-2xl font-semibold mb-4">Modo Presentación</h2>
      <label class="inline-flex items-center">
        <input type="checkbox" id="presentation-mode" class="form-checkbox h-5 w-5 text-blue-600">
        <span class="ml-2 text-gray-600">Cambiar automáticamente entre fractales</span>
      </label>
    </section>
  </div>

  <script>
    // Botón de encendido
    const powerButton = document.getElementById('power-button');
    const powerText = document.getElementById('power-text');
    const projectorStatus = document.getElementById('projector-status');
    let isOn = false;

    powerButton.addEventListener('click', () => {
      isOn = !isOn;
      powerButton.classList.toggle('bg-green-500', isOn);
      powerButton.classList.toggle('bg-gray-200', !isOn);
      powerText.textContent = isOn ? 'Apagar' : 'Encender';
      projectorStatus.innerHTML = `Estado: <span class="${isOn ? 'text-green-600' : 'text-red-600'} font-bold">${isOn ? 'Encendido' : 'Apagado'}</span>`;
    });

    // Simulación de conexión
    const connectButton = document.getElementById('connect-button');
    const connectText = document.getElementById('connect-text');

    connectButton.addEventListener('click', () => {
      connectText.textContent = 'Buscando...';
      connectButton.disabled = true;

      // Simulamos la búsqueda de dispositivos
      setTimeout(() => {
        connectText.textContent = 'Conectando...';

        setTimeout(() => {
          // Simulación de conexión exitosa
          connectText.textContent = 'Conectado';
          connectButton.classList.toggle('bg-blue-500', true);
          connectButton.classList.toggle('bg-blue-200', false);
          connectButton.disabled = false;

          // Cambiar estado del proyector a encendido
          if (!isOn) {
            powerButton.click(); // Encender el proyector si no está encendido
          }
        }, 2000); // Simula el tiempo de conexión
      }, 2000); // Simula el tiempo de búsqueda
    });

    // Zoom Slider
    const zoomSlider = document.getElementById('zoom-slider');
    const zoomValue = document.getElementById('zoom-value');
    const zoomLabel = document.getElementById('zoom-label');
    zoomSlider.addEventListener('input', () => {
      const zoom = zoomSlider.value;
      zoomValue.textContent = `Zoom: ${zoom}`;
      zoomLabel.textContent = zoom;
      drawFractal(zoom); // Actualizar el fractal con el nuevo zoom
    });

    // Generador de fractales
    const canvas = document.getElementById('fractal-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    const colorPicker = document.getElementById('color-picker');
    const fractalSelector = document.getElementById('fractal-selector');
    const generateButton = document.getElementById('generate-button');
    const realPartInput = document.getElementById('real-part');
    const imaginaryPartInput = document.getElementById('imaginary-part');
    const iterationsInput = document.getElementById('iterations');

    // Cambiar el evento del selector de fractales
    fractalSelector.addEventListener('change', () => {
      const zoom = parseFloat(zoomSlider.value);
      const baseColor = colorPicker.value;
      const realPart = parseFloat(realPartInput.value);
      const imaginaryPart = parseFloat(imaginaryPartInput.value);
      const iterations = parseInt(iterationsInput.value, 10);
      drawFractal(fractalSelector.value, zoom, baseColor, realPart, imaginaryPart, iterations);
    });

    // Dibuja el fractal inicial
    drawFractal('mandelbrot', 1, '#0000ff', -0.7, 0.27015, 1000);



    generateButton.addEventListener('click', () => {
      const zoom = parseFloat(zoomSlider.value);
      const baseColor = colorPicker.value; // Color seleccionado por el usuario
      const fractalType = fractalSelector.value;
      const realPart = parseFloat(realPartInput.value);
      const imaginaryPart = parseFloat(imaginaryPartInput.value);
      const iterations = parseInt(iterationsInput.value, 10);

      drawFractal(fractalType, zoom, baseColor, realPart, imaginaryPart, iterations);
    });

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }


    function getColor(iteration, maxIterations, baseColor) {
      const { r, g, b } = hexToRgb(baseColor); // Convertimos el color base a RGB
      const t = iteration / maxIterations; // Proporción de iteraciones completadas
      const alpha = Math.pow(t, 0.5); // Opcional: ajustar la progresión visual

      // Interpolamos los valores de color y retornamos en formato RGBA
      return `rgba(${Math.floor(r * t)}, ${Math.floor(g * t)}, ${Math.floor(b * t)}, ${alpha})`;
    }


    function drawFractal(type, zoom, color, realPart, imaginaryPart, iterations) {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar el lienzo
      ctx.fillStyle = color; // Establecer el color seleccionado

      if (type === 'mandelbrot') {
        drawMandelbrot(zoom, color, realPart, imaginaryPart, iterations);
      } else if (type === 'julia') {
        drawJulia(zoom, color, realPart, imaginaryPart, iterations);
      } else if (type === 'sierpinski') {
        drawSierpinski(color); // No necesita zoom
      }
    }


    function drawMandelbrot(zoom, baseColor, realPart, imaginaryPart, iterations) {
        const maxIterations = iterations;
        const width = canvas.width;
        const height = canvas.height;

        // Centramos el fractal en el medio del canvas
        const centerX = width / 2;
        const centerY = height / 2;

        // Escala del conjunto de Mandelbrot
        const scaleX = 3 / zoom;  // Reduce el valor de escala para hacerlo más grande
        const scaleY = 2.0 / zoom;  // Ajusta este valor según cómo quieras la proporción

        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                // Convertimos las coordenadas pixel a coordenadas complejas
                const cRe = (x - centerX) / (width / 3) * scaleX + realPart;
                const cIm = (y - centerY) / (height / 2.0) * scaleY + imaginaryPart;

                let zx = 0, zy = 0;
                let iteration = 0;

                // Iteración para calcular el conjunto de Mandelbrot
                while (zx * zx + zy * zy < 4 && iteration < maxIterations) {
                    const temp = zx * zx - zy * zy + cRe;
                    zy = 2.0 * zx * zy + cIm;
                    zx = temp;
                    iteration++;
                }

                // Asignar colores según el resultado
                if (iteration === maxIterations) {
                    // Puntos dentro del conjunto: usa el color base
                    ctx.fillStyle = baseColor;
                } else {
                    // Puntos fuera del conjunto: usa un degradado
                    ctx.fillStyle = getColor(iteration, maxIterations, baseColor);
                }

                // Dibujamos un punto en las coordenadas correspondientes
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }






    function drawJulia(zoom, baseColor, realPart, imaginaryPart, iterations) {
      const maxIterations = iterations;
      const width = canvas.width;
      const height = canvas.height;

      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          // Coordenadas iniciales del plano complejo
          let zx = 1.5 * (x - width / 2) / (0.5 * zoom * width);
          let zy = (y - height / 2) / (0.5 * zoom * height);

          const cRe = realPart; // c es constante (real)
          const cIm = imaginaryPart; // c es constante (imaginario)

          let iteration = 0;

          while (zx * zx + zy * zy < 4 && iteration < maxIterations) {
            let temp = zx * zx - zy * zy + cRe;
            zy = 2.0 * zx * zy + cIm;
            zx = temp;
            iteration++;
          }

          ctx.fillStyle = iteration === maxIterations ? 'black' : getColor(iteration, maxIterations, baseColor);
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }


    function drawSierpinski(color) {
      // Dibujar el fractal de Sierpinski (triángulo)
      ctx.fillStyle = color;
      drawTriangle(0, canvas.height, canvas.width, canvas.height, canvas.width / 2, 0, 7); // Recursión
    }

    function drawTriangle(x1, y1, x2, y2, x3, y3, depth) {
      if (depth === 0) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        ctx.fill();
      } else {
        const mx1 = (x1 + x2) / 2;
        const my1 = (y1 + y2) / 2;
        const mx2 = (x2 + x3) / 2;
        const my2 = (y2 + y3) / 2;
        const mx3 = (x1 + x3) / 2;
        const my3 = (y1 + y3) / 2;

        drawTriangle(x1, y1, mx1, my1, mx3, my3, depth - 1);
        drawTriangle(mx1, my1, x2, y2, mx2, my2, depth - 1);
        drawTriangle(mx3, my3, mx2, my2, x3, y3, depth - 1);
      }
    }


        // Inicializar el fractal cuando se selecciona
      fractalSelector.addEventListener('change', drawFractal);

      // Dibuja el fractal inicial
      drawFractal();

      let presentationInterval;

    // Agregar el evento para activar/desactivar el modo de presentación
    document.getElementById('presentation-mode').addEventListener('change', (e) => {
      if (e.target.checked) {
        presentationInterval = setInterval(() => {
          const fractals = ['mandelbrot', 'julia', 'sierpinski'];
          const current = fractalSelector.value;
          const nextIndex = (fractals.indexOf(current) + 1) % fractals.length;

          // Cambiar al siguiente fractal
          fractalSelector.value = fractals[nextIndex];

          // Obtener el color seleccionado por el usuario
          const selectedColor = document.getElementById('color-picker').value;

          // Generar el fractal automáticamente con el color seleccionado
          generateFractal(fractals[nextIndex], selectedColor);
        }, 5000); // Cambiar cada 5 segundos
      } else {
        clearInterval(presentationInterval);
      }
    });

    // Generar fractal según el tipo seleccionado y el color
    function generateFractal(type, color) {
      const zoom = 1; 
      let realPart = 0;
      let imaginaryPart = 0;
      const iterations = 100;

      if (type === 'julia') {
        realPart = -0.7; // Ajusta valores predeterminados
        imaginaryPart = 0.27015;
      }

      drawFractal(type, zoom, color, realPart, imaginaryPart, iterations);
    }



    // Escuchar cambios en el selector y generar el fractal automáticamente
    fractalSelector.addEventListener('change', () => {
      const selectedFractal = fractalSelector.value;
      generateFractal(selectedFractal);
    });

    </script>
  </body>
  </html>